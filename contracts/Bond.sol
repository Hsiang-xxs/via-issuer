// (c) Kallol Borah, 2020
// Implementation of the Via zero coupon bond.

pragma solidity >=0.5.0 <0.7.0;

import "./erc/ERC20.sol";
import "./oraclize/ViaOracle.sol";
import "abdk-libraries-solidity/ABDKMathQuad.sol";
import "@openzeppelin/upgrades/contracts/Initializable.sol";
import "@openzeppelin/contracts-ethereum-package/contracts/ownership/Ownable.sol";
import "./Factory.sol";
import "./Cash.sol";
import "./Token.sol";

contract Bond is ERC20, Initializable, Ownable {

    using ABDKMathQuad for uint256;
    using ABDKMathQuad for int256;
    using ABDKMathQuad for bytes16;

    //via token factory address
    Factory private factory;

    //via oracle
    ViaOracle private oracle;

    //name of Via token (eg, Via-USD)
    bytes32 public name;
    bytes32 public symbol;

    //token address
    address private token;

    //requestor (msg sender address)
    address payable requestor;
    //forwarding token address
    address private forwarder;

    //ether balances held by this issuer against which via bond tokens are issued
    mapping(address => bytes16) private ethbalances;

    //a Via bond has some value, corresponds to a fiat currency
    //can have many purchasers and a issuer that have agreed to a zero coupon rate which is the start price of the bond
    //and a tenure in unix timestamps of seconds counted from 1970-01-01. Via bonds are of one year tenure.
    struct bond{
        address[] counterParties;
        bytes16 parValue;
        bytes16 price;
        bytes16 purchasedIssueAmount;
        bytes16 collateralAmount;
        bytes32 collateralCurrency;
        uint256 timeSubscribed;
    }

    //mapping issuer (address) to address of bond token (address) which acts as identifier for bonds on offer
    mapping(address => mapping (address => bond)) public issues;

    //mapping purchaser (address) to address of bond token (address) which acts as identifier for bonds subscribed
    mapping(address => mapping (address => bond)) public purchases;

    //array of issues of this via bond, where bond IDs are their addresses of their token issues
    address[] private bondsIssued;

    //array of issuers
    address[] private issuers;

    //for Oraclize
    bytes32 EthXid;
    bytes32 ViaXid;
    bytes32 ViaRateId;
    
    //data structure holding details of currency conversion requests pending on oraclize
    struct conversion{
        bytes32 operation;
        address party;
        bytes16 amount;
        bytes32 paid_in_currency;
        bytes32 EthXid;
        bytes16 EthXvalue;
        bytes32 bond_currency;
        bytes16 ViaXvalue;
        bytes32 ViaRateId;
        bytes16 ViaRateValue;
    }

    //queue of pending conversion requests with each pending request mapped to a request_id returned by oraclize
    mapping(bytes32 => conversion) private conversionQ;

    //events to capture and report to Via oracle
    event ViaBondIssued(bytes32 currency, uint256 value, uint256 price, uint256 tenure);
    event ViaBondRedeemed(bytes32 currency, uint256 value, uint256 price, uint256 tenure);

    //initiliaze proxies
    function initialize(bytes32 _name, bytes32 _type, address _owner, address _oracle, address _token) public {
        Ownable.initialize(_owner);
        factory = Factory(_owner);
        oracle = ViaOracle(_oracle);
        name = _name;
        symbol = _type;
        token = _token;
    }

    //handling pay in of ether for issue of via bond tokens
    function() external payable{
        //ether paid in
        require(msg.value !=0);
        //issue via bond tokens
        issue(ABDKMathQuad.fromUInt(msg.value), msg.sender, "ether", address(this));
    }

    //forwarding call from issued bond token if at all such a call arrives
    function transferFoward(address payable _requestor, address _forwarder, address _sender, address _receiver, uint256 _tokens) public returns (bool){
        requestor = _requestor;
        forwarder = _forwarder;
        if(transferFrom(_sender, _receiver, _tokens))
            return true;
        else
            return false;
    }

    //overriding this function of ERC20 standard
    function transferFrom(address sender, address receiver, uint256 tokens) public returns (bool){
        //check if tokens are being transferred to this bond contract
        if(receiver == address(this) || receiver == forwarder){
            //if token name is the same, this transfer has to be redeemed
            if(Token(address(msg.sender)).name()==name || Token(requestor).name()==name){
                if(redeem(ABDKMathQuad.fromUInt(tokens), sender, name, "ViaBond"))
                    return true;
                else
                    return false;
            }
            //else request issue of bond tokens generated by this contract
            else{
                //issue only if paid in tokens are cash tokens, since bond tokens can't be paid to issue bond token
                address viaAddress = factory.getIssuer("ViaCash", Cash(address(msg.sender)).name());
                if(viaAddress!=address(0x0)){
                    if(issue(ABDKMathQuad.fromUInt(tokens), sender, Cash(address(msg.sender)).name(), viaAddress))
                        return true;
                    else
                        return false;
                }
                else{
                    viaAddress = factory.getIssuer("ViaCash", Cash(requestor).name());
                    if(viaAddress!=address(0x0)){
                        if(issue(ABDKMathQuad.fromUInt(tokens), sender, Cash(requestor).name(), viaAddress))
                            return true;
                        else
                            return false;
                    }
                }
                return false;
            }
        }
        else {
           //bond tokens are being sent to a user account
            //confirm if this is the bond issuer
            address issuedBond=address(0x0);
            if(Token(address(msg.sender)).name()==name){
                issuedBond = factory.getProduct(Token(address(msg.sender)).symbol());
            }
            else if(Token(requestor).name()==name){
                issuedBond = factory.getProduct(Token(requestor).symbol());
            }
            if(issuedBond!=address(0x0)){
                //sender is transferring its full purchase amount of bonds
                if(ABDKMathQuad.cmp(purchases[sender][issuedBond].purchasedIssueAmount, ABDKMathQuad.fromUInt(tokens))==0){
                    purchases[receiver][issuedBond] = issues[sender][issuedBond];
                    delete purchases[sender][issuedBond];
                    if(Token(issuedBond).transferToken(sender, receiver, tokens)){
                        emit Transfer(sender, receiver, tokens);
                        return true;
                    }
                }
            }
            return false;
        }
    }

    //requesting issue of Via bonds to payer (issuer) that can pay in ether, or 
    //requesting transfer of Via bonds to payer (buyer) that can pay in via cash tokens
    function issue(bytes16 amount, address payer, bytes32 currency, address cashContract) private returns(bool){
        //ensure that brought amount is not zero
        require(amount != 0);
        //adds paid in amount to the paid in currency's cash balance
        if(currency!="ether")
            if(!Cash(address(uint160(cashContract))).addToBalance(amount, payer))
                return false;
        else
            //if ether is paid in, add balance to this bond's ether balances
            ethbalances[cashContract] = ABDKMathQuad.add(ethbalances[cashContract], amount);
        //call Via Oracle to fetch data for bond pricing
        if(currency=="ether"){
            //if ether is paid into a non Via-USD bond contract, the bond contract will issue bond tokens of an equivalent face value.
            //To derive the bond's face value, the exchange rate of ether to Via-USD and then to the currency paid in is applied.
            if(name!="Via-USD"){
                EthXid = oracle.request("eth","ethusd","EthBond", address(this));
                ViaXid = oracle.request(abi.encodePacked("Via_USD_to_", name),"ver","EthBond", address(this));
                conversion memory c = conversionQ[ViaXid];
                c.operation = "issue";
                c.party = payer;
                c.amount = amount;
                c.paid_in_currency = currency;
                c.EthXid = EthXid;
                c.EthXvalue = ABDKMathQuad.fromUInt(0);
                c.bond_currency = name;
                c.ViaXvalue =ABDKMathQuad.fromUInt(0);
            }
            //if ether is paid into a Via-USD bond contract, issuing the bond token will only require the ether to Via-USD exchange rate. 
            else{
                EthXid = oracle.request("eth","ethusd","EthBond", address(this));
                conversion memory c = conversionQ[ViaXid];
                c.operation = "issue";
                c.party = payer;
                c.amount = amount;
                c.paid_in_currency = currency;
                c.EthXid = EthXid;
                c.EthXvalue = ABDKMathQuad.fromUInt(0);
                c.bond_currency = name;
                c.ViaXvalue =ABDKMathQuad.fromUInt(1);
            }
        }
        //if a via cash token is paid into this bond contract
        else{
            //if the via cash token paid in is different from the denomination of this bond, 
            //tokens of this bond need to be transferred from an issuers' account after pricing the bond with applicable coupon rates
            if(currency!=name){
                ViaXid = oracle.request(abi.encodePacked(currency, "_to_", name),"er","Bond", address(this));                
                if(currency!="Via-USD"){
                    ViaRateId = oracle.request(abi.encodePacked("Via_USD_to_", currency), "ir","Bond",address(this));
                }
                else{
                    ViaRateId = oracle.request("USD", "ir","Bond",address(this));
                }
                conversion memory c = conversionQ[ViaXid];
                c.operation = "issue";
                c.party = payer;
                c.amount = amount;
                c.paid_in_currency = currency;
                c.bond_currency = name;
                c.ViaXvalue =ABDKMathQuad.fromUInt(0);
                c.ViaRateId = ViaRateId; 
                c.ViaRateValue = ABDKMathQuad.fromUInt(0);
            }
            //if the via cash token paid in is the same denomination of this bond, we need to first find out if the pay in is for a purchase of bonds or repayment of an earlier issue
            else{
                bool found = false;
                for(uint256 q=0; q<bondsIssued.length; q++){
                    if(ABDKMathQuad.cmp(issues[payer][bondsIssued[q]].parValue, amount)==0 &&
                        issues[payer][bondsIssued[q]].counterParties[0]!=payer){
                        //if the paying in is for repayment of a bond already issued, then
                        //transfer the paid in amount to the bond holder, release the collateral back to the issuer and extinguish the bond
                        found = true;
                        if(!redeem(amount, payer, currency, "ViaCash"))
                            return false;
                    }
                }
                //if the paying in is not for repayment of a bond already issued, then
                //tokens of this bond need to be transferred from an issuer's account after pricing the bond with the domestic (paid in currency) coupon rates
                if(!found){
                    ViaRateId = oracle.request(abi.encodePacked(currency), "ir","Bond",address(this));
                    conversion memory c = conversionQ[ViaRateId];
                    c.operation = "issue";
                    c.party = payer;
                    c.amount = amount;
                    c.paid_in_currency = currency;
                    c.bond_currency = name;
                    c.ViaXvalue =ABDKMathQuad.fromUInt(1);
                    c.ViaRateId = ViaRateId; 
                    c.ViaRateValue = ABDKMathQuad.fromUInt(0);
                }                
            }
        }
        return true;
    }

    //requesting redemption of Via bonds and transfer of ether or via cash collateral to issuer 
    function redeem(bytes16 amount, address payer, bytes32 tokenName, bytes32 tokenType) private returns(bool){
        //if Via bond holder redeems bond on day of expiry, issuer collateral is transferred to bond holder
        if(tokenType=="ViaBond"){
            bool status = false;
            //find if the bond was issued to payer (purchaser) earlier
            for(uint256 q=0; q<bondsIssued.length; q++){
                if(ABDKMathQuad.cmp(purchases[payer][bondsIssued[q]].purchasedIssueAmount, amount)==0){
                    for(uint256 p=0; p<issues[purchases[payer][bondsIssued[q]].counterParties[0]][bondsIssued[q]].counterParties.length; p++){
                        if(payer==issues[purchases[payer][bondsIssued[q]].counterParties[0]][bondsIssued[q]].counterParties[p]){
                            //calculate redemption amount based on duration of holding by bond subscriber
                            uint256 subscribedDays = (purchases[payer][bondsIssued[q]].timeSubscribed - now)/ 60 / 60 / 24;
                            bytes16 redemptionAmount = ABDKMathQuad.mul(ABDKMathQuad.mul(ABDKMathQuad.div(purchases[payer][bondsIssued[q]].parValue, purchases[payer][bondsIssued[q]].price), 
                                                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(subscribedDays),ABDKMathQuad.fromUInt(365))), purchases[payer][bondsIssued[q]].purchasedIssueAmount);
                            //if collateral is ether, transfer ether from issuer to purchaser (redeemer) of bond
                            if(purchases[payer][bondsIssued[q]].collateralCurrency=="ether"){
                                ethbalances[address(this)] = ABDKMathQuad.sub(ethbalances[address(this)], redemptionAmount);
                                //send redeemed ether to payer
                                address(uint160(payer)).transfer(ABDKMathQuad.toUInt(redemptionAmount));
                                //adjust total supply of this via bond
                                Token(bondsIssued[q]).reduceSupply(amount);
                                //reduce payer's balance of bond held
                                Token(bondsIssued[q]).reduceBalance(payer, amount);
                                //generate event
                                emit ViaBondRedeemed(tokenName, ABDKMathQuad.toUInt(redemptionAmount), ABDKMathQuad.toUInt(purchases[payer][bondsIssued[q]].purchasedIssueAmount), subscribedDays);
                                status = true;
                            }
                            delete(purchases[payer][bondsIssued[q]]);
                            delete(issues[payer][bondsIssued[q]].counterParties[p]);
                        }
                    }
                }
            }
            //find if the bond was issued to payer (issuer) earlier
            for(uint256 q=0; q<bondsIssued.length; q++){
                if(ABDKMathQuad.cmp(ABDKMathQuad.sub(issues[payer][bondsIssued[q]].parValue, issues[payer][bondsIssued[q]].purchasedIssueAmount), amount)==0){
                    //calculate redemption amount based on how much collateral is not encumbered
                    uint256 issuedDays = (issues[payer][bondsIssued[q]].timeSubscribed - now)/ 60 / 60 / 24;
                    bytes16 uncumberedAmount = ABDKMathQuad.sub(issues[payer][bondsIssued[q]].parValue, issues[payer][bondsIssued[q]].purchasedIssueAmount);
                    //if collateral is ether, transfer ether from issuer to issuer (redeemer) of bond
                    if(issues[payer][bondsIssued[q]].collateralCurrency=="ether"){
                        ethbalances[address(this)] = ABDKMathQuad.sub(ethbalances[address(this)], uncumberedAmount);
                        //send redeemed ether to payer
                        address(uint160(payer)).transfer(ABDKMathQuad.toUInt(uncumberedAmount));
                        //adjust total supply of this via bond
                        Token(bondsIssued[q]).reduceSupply(amount);
                        //reduce payer's balance of bond held
                        Token(bondsIssued[q]).reduceBalance(payer, amount);
                        //generate event
                        emit ViaBondRedeemed(tokenName, ABDKMathQuad.toUInt(uncumberedAmount), ABDKMathQuad.toUInt(amount), issuedDays);
                        status = true;
                    }
                    if(status && ABDKMathQuad.cmp(issues[payer][bondsIssued[q]].collateralAmount, amount)==0){
                        //if bond is redeemed in full by issuer, then remove issue from list of issues
                        delete(issues[payer][bondsIssued[q]]);
                    }
                    else{
                        //else, if bond is redeemed partially by issuer, then adjust redeemed amount with collateral balance in purchaser accounts
                        for(uint256 p=0; p<issues[payer][bondsIssued[q]].counterParties.length; p++){
                            purchases[issues[payer][bondsIssued[q]].counterParties[p]][bondsIssued[q]].collateralAmount = 
                            ABDKMathQuad.sub(purchases[issues[payer][bondsIssued[q]].counterParties[p]][bondsIssued[q]].collateralAmount, uncumberedAmount);
                        }
                    }
                }
            }
            return status;
        }
        //if Via bond issuer pays in cash for redemption, it is paid back to Via bond holders and collateral paid back to issuers
        else{
            address viaAddress;
            bool status = false;
            bytes16 totalToRedeem;
            //find the bond that was issued by payer (issuer) earlier
            for(uint256 q=0; q<bondsIssued.length; q++){
                if(ABDKMathQuad.cmp(amount, issues[payer][bondsIssued[q]].purchasedIssueAmount)==1){
                    for(uint256 p=0; p<issues[payer][bondsIssued[q]].counterParties.length; p++){
                        status = false;
                        address cp = issues[payer][bondsIssued[q]].counterParties[p];
                        //if collateral is ether, release collateral and transfer ether to issuer of bond
                        //and send paid in amount to purchaser of bond
                        if(issues[payer][bondsIssued[q]].collateralCurrency=="ether"){
                            //calculate redemption amount based on duration of holding by bond subscriber
                            uint256 subscribedDays = (purchases[cp][bondsIssued[q]].timeSubscribed - now)/ 60 / 60 / 24;
                            bytes16 redemptionAmount = ABDKMathQuad.mul(ABDKMathQuad.mul(ABDKMathQuad.div(purchases[cp][bondsIssued[q]].parValue, 
                                                        purchases[cp][bondsIssued[q]].price), 
                                                        ABDKMathQuad.div(ABDKMathQuad.fromUInt(subscribedDays),ABDKMathQuad.fromUInt(365))), 
                                                        purchases[cp][bondsIssued[q]].purchasedIssueAmount);
                            //if amount available for redemption is more or equal to redemption amount for the purchaser
                            if(amount >= redemptionAmount){
                                //send paid in amount to bond purchaser
                                viaAddress = factory.getIssuer("ViaCash", tokenName);
                                if(viaAddress!=address(0x0)){
                                    bytes16 balanceToRedeem = Cash(address(uint160(viaAddress))).deductFromBalance(redemptionAmount, cp);
                                    //adjust total supply of this via bond
                                    Token(bondsIssued[q]).reduceSupply(redemptionAmount);     
                                    //reduce counter party's balance of bond held
                                    Token(bondsIssued[q]).reduceBalance(cp, redemptionAmount);
                                    totalToRedeem = ABDKMathQuad.add(totalToRedeem, balanceToRedeem);
                                    //if balance left to redeem is 0
                                    if(balanceToRedeem==0){
                                        //adjust amount available for redemption 
                                        amount = ABDKMathQuad.sub(amount, redemptionAmount);
                                        //generate event
                                        emit ViaBondRedeemed(tokenName, ABDKMathQuad.toUInt(redemptionAmount), ABDKMathQuad.toUInt(purchases[cp][bondsIssued[q]].purchasedIssueAmount), subscribedDays);
                                        status = true; 
                                    }
                                    else{
                                        //adjust amount available for redemption 
                                        amount = ABDKMathQuad.sub(amount, ABDKMathQuad.sub(redemptionAmount, balanceToRedeem));
                                        //generate event
                                        emit ViaBondRedeemed(tokenName, ABDKMathQuad.toUInt(balanceToRedeem), ABDKMathQuad.toUInt(purchases[cp][bondsIssued[q]].purchasedIssueAmount), subscribedDays);
                                    }
                                }
                            }  
                        }
                        if(status)
                            //if a purchaser is redeemed, then delete its record from list of purchases
                            delete(purchases[cp][bondsIssued[q]]);
                        if(p==issues[payer][bondsIssued[q]].counterParties.length-1)
                            //if all bond purchasers are redeemed, then delete the issuer record
                            delete(issues[payer][bondsIssued[q]]);
                    }
                    //find proportion to redeem
                    bytes16 proportionToRedeem = ABDKMathQuad.div(totalToRedeem, issues[payer][bondsIssued[q]].purchasedIssueAmount);
                    //returned redeemed proportion of collateral to payer (issuer)
                    bytes16 etherToRedeem = ABDKMathQuad.mul(issues[payer][bondsIssued[q]].collateralAmount, ABDKMathQuad.sub(ABDKMathQuad.fromUInt(1), proportionToRedeem));
                    ethbalances[address(this)] = ABDKMathQuad.sub(ethbalances[address(this)], etherToRedeem);
                    //send redeemed ether to payer
                    address(uint160(payer)).transfer(ABDKMathQuad.toUInt(etherToRedeem));                                   
                    //if any balance amount remains after redemptions, return the balance to the issuer
                    if(amount>0)
                        address(uint160(payer)).transfer(ABDKMathQuad.toUInt(amount));
                }
            }
            return status;
        }
    }

    //function called back from Oraclize
    function convert(bytes32 txId, bytes16 result, bytes32 rtype) public {
        //check type of result returned
        if(rtype =="ethusd"){
            conversionQ[txId].EthXvalue = result;
        }
        if(rtype == "ir"){
            conversionQ[txId].ViaRateValue = result;
        }
        if(rtype == "er"){
            conversionQ[txId].EthXvalue = result;
        }
        if(rtype == "ver"){
            conversionQ[txId].ViaXvalue = result;
        }
        //check if bond needs to be issued
        if(conversionQ[txId].operation=="issue"){
            if(rtype == "ethusd" || rtype == "ver"){
                if(ABDKMathQuad.cmp(conversionQ[txId].EthXvalue, ABDKMathQuad.fromUInt(0))!=0 &&
                    ABDKMathQuad.cmp(conversionQ[txId].ViaXvalue, ABDKMathQuad.fromUInt(0))!=0){
                    //calculate par value of via bond by applying exchange rates from via oracle    
                    bytes16 parValue = convertToVia(conversionQ[txId].amount, conversionQ[txId].paid_in_currency,conversionQ[txId].EthXvalue,conversionQ[txId].ViaXvalue);
                    //calculate price of via bond by applying interest rates from via oracle
                    bytes16 viaBondPrice = ABDKMathQuad.div(parValue, ABDKMathQuad.add(ABDKMathQuad.fromUInt(1), ABDKMathQuad.fromUInt(0)))^ABDKMathQuad.fromUInt(1);
                    //issue bond to issuer
                    finallyIssue(conversionQ[txId].party, parValue, viaBondPrice, conversionQ[txId].amount, conversionQ[txId].paid_in_currency);
                }
            }
            else if(rtype == "er" || rtype =="ir"){
                if(ABDKMathQuad.cmp(conversionQ[txId].ViaXvalue, ABDKMathQuad.fromUInt(0))!=0 && 
                    ABDKMathQuad.cmp(conversionQ[txId].ViaRateValue, ABDKMathQuad.fromUInt(0))!=0){
                    //calculate par value of via bond by applying exchange rates from via oracle
                    bytes16 parValue = convertToVia(conversionQ[txId].amount, conversionQ[txId].paid_in_currency,conversionQ[txId].EthXvalue,conversionQ[txId].ViaXvalue);
                    //calculate price of via bond by applying interest rates from via oracle
                    bytes16 viaBondPrice = ABDKMathQuad.div(parValue, ABDKMathQuad.add(ABDKMathQuad.fromUInt(1), conversionQ[txId].ViaRateValue))^ABDKMathQuad.fromUInt(1);
                    //transfer bond from issuer to purchaser, and transfer paid in cash token from purchaser to issuer
                    finallyIssue(conversionQ[txId].party, parValue, viaBondPrice, conversionQ[txId].amount, conversionQ[txId].paid_in_currency);
                }
            }
        }
    }

    //issue bond tokens if ether is paid in, or transfer bond tokens if via cash tokens are paid in
    function finallyIssue(address payer, bytes16 parValue, bytes16 bondPrice, bytes16 paidInAmount, bytes32 paidInCashToken) private {
        bool found = false;
        if(paidInCashToken=="ether"){
            uint256 issueTime = now;
            //issue bond which initializes a token with the attributes of the bond
            address issuedBond = factory.createToken(token, name, symbol, abi.encodePacked(address(this),issueTime));
            //adjust issued bonds to total supply first
            Token(issuedBond).addTotalSupply(parValue);
            //issue bond to payer if ether is paid in as collateral
            Token(issuedBond).transfer(payer, ABDKMathQuad.toUInt(parValue));    
            //keep track of issues
            storeBond("issue", payer, payer, parValue, bondPrice, ABDKMathQuad.fromUInt(0), paidInAmount, paidInCashToken, issueTime, issuedBond);
            bondsIssued.push(issuedBond);
            //keep track of issuers
            for(uint256 i=0; i<issuers.length; i++){
                if(issuers[i]==payer)
                    found = true;
            }
            if(!found)
                issuers.push(payer);
        }
        //paid in amount is Via cash
        else{
            for(uint256 i=0; i<issuers.length; i++){
                for(uint256 q=0; q<bondsIssued.length; q++){
                    //check if there are enough issued bonds to be purchased
                    if(ABDKMathQuad.cmp(ABDKMathQuad.sub(issues[issuers[i]][bondsIssued[q]].parValue, issues[issuers[i]][bondsIssued[q]].purchasedIssueAmount), paidInAmount)==0 ||
                        ABDKMathQuad.cmp(ABDKMathQuad.sub(issues[issuers[i]][bondsIssued[q]].parValue, issues[issuers[i]][bondsIssued[q]].purchasedIssueAmount), paidInAmount)==1){
                        //if there is enough issued bonds, transfer bond from issuer to payer
                        Token(bondsIssued[q]).transfer(payer, ABDKMathQuad.toUInt(paidInAmount));            
                        //add purchaser as counter party in issuer's record
                        if(issues[issuers[i]][bondsIssued[q]].counterParties.length==1)
                            issues[issuers[i]][bondsIssued[q]].counterParties[0] = payer;
                        else
                            issues[issuers[i]][bondsIssued[q]].counterParties[issues[issuers[i]][bondsIssued[q]].counterParties.length] = payer;
                        //reduce issuable value of bond by amount transferred to purchaser
                        issues[issuers[i]][bondsIssued[q]].purchasedIssueAmount = ABDKMathQuad.add(issues[issuers[i]][bondsIssued[q]].purchasedIssueAmount, paidInAmount); 
                        //add bond to purchaser's record
                        storeBond("purchase", payer, issuers[i], parValue, bondPrice, issues[issuers[i]][bondsIssued[q]].purchasedIssueAmount, paidInAmount, paidInCashToken, now, bondsIssued[q]);
                        //transfer cash paid in by purchaser to issuer from whom bond is transferred to purchaser
                        address viaAddress = factory.getIssuer("ViaCash", paidInCashToken);
                        if(viaAddress!=address(0x0)){
                            //deduct paid out cash token from purchaser cash balance
                            Cash(address(uint160(viaAddress))).deductFromBalance(paidInAmount, issuers[i]);
                        }
                    }
                }
            }    
        }
        //generate event
        emit ViaBondIssued(name, ABDKMathQuad.toUInt(parValue), ABDKMathQuad.toUInt(paidInAmount), 1);
    }

    //convert given currency and amount to via cash token
    function convertToVia(bytes16 amount, bytes32 currency, bytes16 ethusd, bytes16 viarate) private returns(bytes16){
        if(currency=="ether"){
            //to first convert amount of ether passed to this function to USD
            bytes16 amountInUSD = ABDKMathQuad.mul(ABDKMathQuad.div(amount, ABDKMathQuad.fromUInt(1000000000000000000)), ethusd);
            //to then convert USD to Via-currency if currency of this contract is not USD itself
            if(name!="Via-USD"){
                bytes16 inVia = ABDKMathQuad.mul(amountInUSD, viarate);
                return inVia;
            }
            else{
                return amountInUSD;
            }
        }
        //if currency paid in another via currency
        else{
            bytes16 inVia = ABDKMathQuad.mul(amount, viarate);
            return inVia;
        }
    }

    //stores issued and purchased bond details
    function storeBond( bytes32 _operation,
                        address _payer,
                        address _party,
                        bytes16 _parValue,
                        bytes16 _bondPrice,
                        bytes16 _purchasedIssueAmount,
                        bytes16 _paidInAmount,
                        bytes32 _paidInCashToken,
                        uint256 _timeIssued,
                        address _issuedBond) private {
        if(_operation=="issue"){
            issues[_payer][_issuedBond].counterParties[0] = _party;
            issues[_payer][_issuedBond].parValue = _parValue;
            issues[_payer][_issuedBond].price = _bondPrice;
            issues[_payer][_issuedBond].purchasedIssueAmount = _purchasedIssueAmount;
            issues[_payer][_issuedBond].collateralAmount = _paidInAmount;
            issues[_payer][_issuedBond].collateralCurrency = _paidInCashToken;
            issues[_payer][_issuedBond].timeSubscribed = _timeIssued;
        }
        else if(_operation=="purchase"){
            purchases[_payer][_issuedBond].counterParties[0] = _party;
            purchases[_payer][_issuedBond].parValue = _parValue;
            purchases[_payer][_issuedBond].price = _bondPrice;
            purchases[_payer][_issuedBond].purchasedIssueAmount = _purchasedIssueAmount;
            purchases[_payer][_issuedBond].collateralAmount = _paidInAmount;
            purchases[_payer][_issuedBond].collateralCurrency = _paidInCashToken;
            purchases[_payer][_issuedBond].timeSubscribed = _timeIssued;
        }
    }

}
